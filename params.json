{"name":"TSboilerplate","body":"A project to be used as the starting point for a new iOS project\r\n>\r\nIncludes \r\nMKNetworkKit\t\r\nMogenerator (Arc and NSCoding support for model files)\r\n\r\n## Data persistance:\r\nDefine your model using core data UI - add entities and properties. (Any properties that you want to persist must have a data type that supports NSCoding).\r\nInverse relationships are not supported at this stage.\r\nThe objects are generated as .h and .m files when you run the Generate Data Model target. \r\nYou will have to drag newly generated class files into your project from finder. Model files are placed in ./Model/ModelObjects in Human and Machine folders. \r\nYou are supposed to modify the human files only! This is for adding custom methods to your model objects should you desire them.\r\nAn example might be adding an accessor method to your model object that returns and ordered array for that model object's NSSet property. You would add this to the Human/ClassName.h and .m files. your patterns are your own, so this is not necessary. Do what you want!\r\n\r\n## Networking: \r\nTo use the networking subsystem - Mugunth Kumar is the man! https://github.com/MugunthKumar/MKNetworkKit\r\n\r\n## Commands:\r\nThe commands subsystem is broken up into synchronous and asynchronous command which are exected by TSCommandRunner.\r\nCommands are the method of having your controllers tell \"the system\" to do something and don't get bogged down with the business logic. As a general rule, anything can READ from the Model. As a general rule, only COMMANDS can change the model. \r\nYour view controller will get the user's data, for example a name, and set that on a command. It will then run a command to update a model object with that data. This allows decoupling of view controllers to model objects.\r\n\r\nExample usage for Synchronous\r\n\r\n    GroupCommand *groupCommand = [GroupCommand new];\r\n    groupCommand.groupName = kGroupName;\r\n    groupCommand.saveModel = YES; // at the end of the execute method, save the model.\r\n    [[TSCommandRunner sharedCommandRunner] executeSynchronousCommand:groupCommand];`\r\n\r\nor Asynchronous\r\n\r\n    MemberDisplayCommand *memberDisplayCommand = [MemberDisplayCommand new];\r\n    memberDisplayCommand.group = [Model sharedModel].group;\r\n    memberDisplayCommand.commandCompletionBlock = ^ (NSError *error) {\r\n        DLog(@\"Your first completion block!\");\r\n        DLog(@\"Erorr says: %@\", [error localizedDescription]);\r\n    };\r\n    [[TSCommandRunner sharedCommandRunner] executeAsynchronousCommand:memberDisplayCommand];`","tagline":"Boiler plate repository for getting a new iOS project up and running quickly.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}